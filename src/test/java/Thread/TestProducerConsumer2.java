package Thread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @program: spring-demo * @description: 生产者和消费者，ReentrantLock的实现 * @author: gonghuihui * @create: 2019-04-10 14:34 **/public class TestProducerConsumer2 {    private static Integer count = 0;    private static final Integer FULL = 10;    // 创建锁对象    private Lock lock = new ReentrantLock();    // 创建两个条件变量，一个为缓存区非满，一个为缓存区非空    private final Condition notFull = lock.newCondition();    private final Condition notEmpty = lock.newCondition();    class Producer implements Runnable {        @Override        public void run() {            for (int i = 0; i < 10; i++) {                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                lock.lock();                try {                    while (count == FULL) {                        try {                            notFull.await();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    count++;                    System.out.println(Thread.currentThread().getName()                            + "生产者生产，目前总共有" + count);                    // 唤醒消费者                    notEmpty.signal();                } finally {                    // 释放锁                    lock.unlock();                }            }        }    }    class Consumer implements Runnable {        @Override        public void run() {            for (int i = 0; i < 10; i++) {                try {                    Thread.sleep(3000);                } catch (InterruptedException e1) {                    e1.printStackTrace();                }                lock.lock();                try {                    while (count == 0) {                        try {                            notEmpty.await();                        } catch (InterruptedException e1) {                            e1.printStackTrace();                        }                    }                    count--;                    System.out.println(Thread.currentThread().getName()                            + "消费者消费，目前共有" + count);                    notFull.signal();                } finally {                    lock.unlock();                }            }        }    }    public static void main(String[] args) {        TestProducerConsumer2 tp2 = new TestProducerConsumer2();        new Thread(tp2.new Producer()).start();        new Thread(tp2.new Consumer()).start();        new Thread(tp2.new Producer()).start();        new Thread(tp2.new Consumer()).start();    }}