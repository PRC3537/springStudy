package Thread;import javax.swing.*;import java.security.cert.TrustAnchor;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * @program: spring-demo * @description: 使用BlockingQueue实现生产者消费者模型 * @author: gonghuihui * @create: 2019-04-11 15:43 **/public class TestProduceConsumer3 {    private static Integer count = 0;    // 创建一个阻塞队列    final BlockingQueue blockingQueue = new ArrayBlockingQueue<>(10);    class Produce implements Runnable {        @Override        public void run() {            for (int i = 0; i < 10; i++) {                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                try {                    blockingQueue.put(1);                    count++;                    System.out.println(Thread.currentThread().getName()                    + "生产者生产，目前总共有" + count);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    class Consumer implements Runnable {        @Override        public void run() {            for (int i = 0; i < 10; i++) {                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                try {                    blockingQueue.take();                    count--;                    System.out.println(Thread.currentThread().getName()                    + "消费者消费，目前总共有" + count);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    public static void main(String[] args) {        TestProduceConsumer3 tp3 = new TestProduceConsumer3();        new Thread(tp3.new Produce()).start();        new Thread(tp3.new Consumer()).start();        new Thread(tp3.new Produce()).start();        new Thread(tp3.new Consumer()).start();        new Thread(tp3.new Produce()).start();        new Thread(tp3.new Consumer()).start();        new Thread(tp3.new Produce()).start();        new Thread(tp3.new Consumer()).start();    }}